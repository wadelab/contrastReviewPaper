<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Measuring contrast processing in the visual system using SSVEP (and VEP?)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="review_files/libs/clipboard/clipboard.min.js"></script>
<script src="review_files/libs/quarto-html/quarto.js"></script>
<script src="review_files/libs/quarto-html/popper.min.js"></script>
<script src="review_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="review_files/libs/quarto-html/anchor.min.js"></script>
<link href="review_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="review_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="review_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="review_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="review_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Measuring contrast processing in the visual system using SSVEP (and VEP?)</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="baker-wade-review-vis-neurosci" class="level2">
<h2 class="anchored" data-anchor-id="baker-wade-review-vis-neurosci">Baker, Wade: Review: Vis Neurosci</h2>
</section>
<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">ABSTRACT:</h2>
<p>Cone photoreceptor contrast modulations are the currency of the early visual system. Measuring the way that sensitivity to contrast depends on factors such as spatial and temporal frequency, age, eccentricity, chromaticity and the presence of other stimuli has been a focus of vision science for at least 100 years. One of the most productive experimental approaches in this field has been the use of the ‘steady-state visually-evoked potential’ (SSVEP): a technique where contrast modulating inputs are ’frequency tagged (presented at well-defined frequencies and phases) and the electrical signals that they generate in the brain are analyzed in the temporal frequency domain. SSVEPs have several advantages over conventional measures of visually-evoked responses: they have relatively unambiguous ouput measures, a high SNR and they allow us to analyze interactions between stimulus components using a convenient mathematical framework. Here we describe how SSVEPs have been used to study visual contrast over the past 70 years<span class="citation" data-cites="dawson_summation_1954">(<a href="#ref-dawson_summation_1954" role="doc-biblioref">Dawson 1954</a>)</span>. Because our thinking about SSVEPs is best described in simple mathematical models, we embed code that illustrates key steps in the modelling and analysis. This document can therefore be used both as a review of the use of SSVEP in measuring human contrast processing, and as an interactive learning aid.</p>
<p>Figures:</p>
<p><em>1: a) A typical SSVEP setup: a screen, a grating, a flicker rate: b) The responses from a single electrode (time domain) c) Frequency domain.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> scp</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>inputFrequencies_Hz<span class="op">=</span>np.array([<span class="dv">5</span>,<span class="dv">7</span>]) <span class="co"># We simulate a system with two input frequencies (perhaps contrast-reversing gratings?)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>duration_S<span class="op">=</span><span class="dv">1</span> <span class="co"># All variables in this code have an _[units] where possible</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>digitisationRate_Hz<span class="op">=</span><span class="dv">1000</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>support_S<span class="op">=</span>np.linspace(<span class="dv">0</span>,duration_S,duration_S<span class="op">*</span>digitisationRate_Hz)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>inputModulations <span class="op">=</span> np.zeros((<span class="bu">len</span>(support_S), <span class="bu">len</span>(inputFrequencies_Hz)))</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, freq <span class="kw">in</span> <span class="bu">enumerate</span>(inputFrequencies_Hz):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    inputModulations[:, i] <span class="op">=</span> np.sin(<span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">*</span> freq <span class="op">*</span> support_S)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a figure with two subplots</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>fig, axs <span class="op">=</span> plt.subplots(<span class="bu">len</span>(inputFrequencies_Hz), <span class="dv">1</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each input modulation in a separate subplot</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, freq <span class="kw">in</span> <span class="bu">enumerate</span>(inputFrequencies_Hz):</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    axs[i].plot(support_S, inputModulations[:, i])</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    axs[i].set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    axs[i].set_ylabel(<span class="st">'Amplitude'</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    axs[i].set_title(<span class="st">'Frequency: </span><span class="sc">{}</span><span class="st"> Hz'</span>.<span class="bu">format</span>(freq))</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Adjust the spacing between subplots</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="review_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid" width="768"></p>
</div>
</div>
<p>It is relatively easy to write the same thing in R. This is a ‘machine translation’ using Anthropic’s Claude3 LLM. You need to modify your R environment to include the reticulate package (and probably some others… rmarkdown for one?)</p>
<p>Note that once you have this working, you can pass data back and fore between R and python!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>inputFrequencies_Hz <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">7</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>duration_S <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>digitisationRate_Hz <span class="ot">&lt;-</span> <span class="dv">1000</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>support_S <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>, duration_S, <span class="at">length.out =</span> duration_S <span class="sc">*</span> digitisationRate_Hz)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>inputModulations <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="fu">length</span>(support_S), <span class="at">ncol =</span> <span class="fu">length</span>(inputFrequencies_Hz))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(inputFrequencies_Hz)) {</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  freq <span class="ot">&lt;-</span> inputFrequencies_Hz[i]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  inputModulations[, i] <span class="ot">&lt;-</span> <span class="fu">sin</span>(<span class="dv">2</span> <span class="sc">*</span> pi <span class="sc">*</span> freq <span class="sc">*</span> support_S)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a data frame for plotting</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">Time =</span> <span class="fu">rep</span>(support_S, <span class="fu">length</span>(inputFrequencies_Hz)),</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  <span class="at">Amplitude =</span> <span class="fu">c</span>(inputModulations),</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="at">Frequency =</span> <span class="fu">factor</span>(<span class="fu">rep</span>(inputFrequencies_Hz, <span class="at">each =</span> <span class="fu">length</span>(support_S)))</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the plot using ggplot2</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(data, <span class="fu">aes</span>(<span class="at">x =</span> Time, <span class="at">y =</span> Amplitude)) <span class="sc">+</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>() <span class="sc">+</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span> Frequency, <span class="at">ncol =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">name =</span> <span class="st">"Time (s)"</span>, <span class="at">limits =</span> <span class="fu">c</span>(<span class="dv">0</span>, duration_S)) <span class="sc">+</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_y_continuous</span>(<span class="at">name =</span> <span class="st">"Amplitude"</span>) <span class="sc">+</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggtitle</span>(<span class="st">"Input Modulations"</span>) <span class="sc">+</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>() <span class="sc">+</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">plot.title =</span> <span class="fu">element_text</span>(<span class="at">hjust =</span> <span class="fl">0.5</span>))</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(plot)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="review_files/figure-html/unnamed-chunk-2-3.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The two inputs are represented here as amplitude modulations across time.</p>
<p>If the two inputs are simply added together, the representation of the resulting signal in the Fourier domain is just the linear sum of the two independent signals:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>freqCutoff_Hz<span class="op">=</span><span class="dv">30</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>combinedSignal<span class="op">=</span>np.<span class="bu">sum</span>(inputModulations,axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>FT_combinedSignal<span class="op">=</span>np.fft.fft(combinedSignal)<span class="op">/</span><span class="bu">len</span>(combinedSignal)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>fig,axs<span class="op">=</span>plt.subplots(<span class="dv">1</span>,<span class="dv">2</span>,figsize<span class="op">=</span>(<span class="dv">8</span>,<span class="dv">6</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].plot(support_S,combinedSignal)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_xlabel(<span class="st">'Time (s)'</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_ylabel(<span class="st">'Amplitude (a.u.)'</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">0</span>].set_title(<span class="st">'Input signals with linear combination'</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the frequency support for the FFT plot</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>frequencySupport <span class="op">=</span> np.arange(<span class="dv">1</span>,freqCutoff_Hz<span class="op">*</span>duration_S<span class="op">+</span><span class="dv">1</span>) <span class="co"># We only want to plot the frequencies in the FFT up to this point</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot the absolute values of the FFT in the second axis as a bar plot</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].bar(frequencySupport, np.<span class="bu">abs</span>(FT_combinedSignal[frequencySupport]))</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_xlabel(<span class="st">'Frequency (Hz)'</span>)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_ylabel(<span class="st">'Magnitude (a.u.)'</span>)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>axs[<span class="dv">1</span>].set_title(<span class="st">'FFT of Combined Signal'</span>)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<p><img src="review_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="768"></p>
</div>
</div>
<p><em>2: Sweeps and CRFs. Measurements of contrast sensitivity, extrapolating the sweep to zero response to get t’hold. Infants and adults?</em></p>
<p><em>3: Measurements of modulation. Figures adapted from other papers: Attention to space, attention to features, adaptation (?). masking/surround suppression\</em></p>
<p><em>4: Clinical (Porciatti / Tsai/ Marmite/ Amblyopia / PD?)</em> [<span class="citation" data-cites="porciatti_lack_2000">Porciatti et al. (<a href="#ref-porciatti_lack_2000" role="doc-biblioref">2000</a>)</span>]<span class="citation" data-cites="tsai_contrast_2011">(<a href="#ref-tsai_contrast_2011" role="doc-biblioref">Tsai et al. 2011</a>)</span> <em>5: Future directions (decoding in frequency domain?, animals? BCI?)</em></p>
<p><span id="anchor-2"></span>History</p>
<p><span id="anchor-3"></span>1. The basics of SSVEP and contrast sensitivity including a history of both fields</p>
<p>SSVEP (Steady-State Visual Evoked Potential): A continuous electrical response evoked in the brain by visual stimuli flickering at a constant frequency (Regan, 1966).</p>
<p>Contrast Sensitivity: The ability to detect differences in luminance between an object and its background (Campbell &amp; Green, 1965).</p>
<p>Regan, D. (1966). Some characteristics of average steady-state and transient responses evoked by modulated light. Electroencephalography and clinical neurophysiology, 20(3), 238-248.</p>
<p>Campbell, F. W., &amp; Green, D. G. (1965). Optical and retinal factors affecting visual resolution. J Physiology, 181, 576-593.</p>
<p>Check Regan paper for earlier (e.g.&nbsp;EEG refs). Norcia review will be helpful!</p>
<p>(From Tyler / Levi / Apkarian paper):</p>
<p>6. Regan, D.: Rapid methods for refracting the eye and assessing the visual acuity in amblyopia using steady-state visual evoked potentials. In Desmedt, J.E., editor: Visual Evoked Potentials in Man: New Developments, Oxford, 1977, Clarendon Press, pp.&nbsp;418-426.</p>
<p>7. Fricker, S.J.: Narrow-band filter techniques for the detection and measurement of evoked responses, Electroencephalogr. Clin. Neurophysiol. 14:411, 1962.</p>
<p>8. Van der Tweel, L. H., Sem-Jacobsen, C.W., Kamp, A., Van Leeuwen, W.S., and Verings, F.T.H.: Objective determination of response to modulated light, Acta Physiol. Pharmacol. Neerl. 7:528, 1958.</p>
<p>9. Regan, D.: Latencies of evoked potentials to flicker and to pattern speedily estimated by simultaneous stimulation method, Electroencephalogr. Clin. Neurophysiol. 40:654, 1976.</p>
<p>10. Tyler, C.W., Apkarian, P., and Nakayama, K.: Multiple spatial frequency tuning of electrical responses from the human.…</p>
<p>[Around here perhaps a section about what gain control is, mentioning other methods as well including psychophysics, MRI, electrophysiology, and other EEG markers including ERPs and evoked gamma band oscillations. Maybe outline the Heeger gain control model and its cousins.]</p>
<p>[Sure. But in fact gain control is only a small part of this story - especially in the early days. They were, I think, more interested in using SSVEP to measure absolute contrast sensitivity and to get lower bounds on things like infant visual development. Gain control might be better as a separate section later.]</p>
<p><span id="anchor-4"></span>2. Spatial, temporal frequency and contrast sensitivity measurements</p>
<p>Basically using SSVEP to measure a cortical output amplitude for any given input contrast. You can vary parameters like SF, TF, position, color and of course contrast. Early on people realised that you can ‘sweep’ the stimulus to get a CRF. You broadly get a line in log contrast space if you do that (Tyler) - then you can extrapolate that line down to zero response to estimate the threshold. That doesn’t &gt;quite&lt; work but it’s pretty close.</p>
<p>You can also use this for ‘difficult’ populations like babies. One interesting story was about how SSVEP become a replacement for preferential looking (which was the other way of looking at infant visual development). See e.g.&nbsp;Davida Teller. SSVEPs allowed people to make objective measurements of contrast sensitivity development and deduce that the visual system was more mature (e.g.&nbsp;more functional) in infancy than previously expected. Also measures of colour sensitivity. Tinyeyes is based off those measurements. Other people: Tyler, Norcia, Gunilla H-P, many of the people at SKERI in the 1980s and 90s. Norcia 86,88,90 - mentioned in Regan’s nice autobiography : https://www.google.co.uk/books/edition/Seeing_Spatial_Form/HqaKlR_GpP0C?hl=en&amp;gbpv=1&amp;dq=Analysis+of+EEG+responses+in+man,+evoked+by+sine+watre+modulated+light.+Thesis&amp;pg=PA215&amp;printsec=frontcover</p>
<p>In parallel of course, people were using frequency tagging to do single unit work - the 1F vs 2F simple/complex cell classification scheme was all about this (Lennie and others).</p>
<p><span id="anchor-5"></span>3. SSVEP in functional localization</p>
<p>Techniques like fMRI have been combined with SSVEP to achieve more precise spatial localization (Di Russo et al., 2007). See however the Ales cruciform paper.</p>
<p>Di Russo, F., Pitzalis, S., Spitoni, G., Aprile, T., Patria, F., Stella, A., ... &amp; Hillyard, S. A. (2007). Identification of the neural sources of the pattern-reversal VEP. Neuroimage, 34(1), 177-189.</p>
<p>Ales and Norcia:... (showed that people’s intuition about V1 upper / lower v.f reversing polarity wasn’t really correct). This feels a little outside our scope though... We have also combined SSVEP with source imaging techniques to probe responses in different cortical locations (again, Ales papers, some early stuff from Stan K? Appelbaum, Wade, Norcia figure/ground...) and then a host of later work from that lab and others.</p>
<p><span id="anchor-6"></span>4. SSVEP and contrast gain control including adaptation, masking, and attention</p>
<p>[The story goes: Up to the lte 90s people were primarily interested in measuring contrast sensitivity - the shape of the response function was assumed to be basically log-linear - and they fit it with straight lines to extrapolate back to zero response. But then (once Heeger’s 1992 paper had sunk in - see also stuff like Shapley and Victor 1981 <a href="https://www.zotero.org/google-docs/?zAmtgj">(Shapley &amp; Victor, 1981)</a>), people started thinking about gain control - Candy and Norcia in about 1999, Porciatti, probably a load of Tyler papers that I don’t even know about...]. Probably look in p</p>
<p>And then people worked out that if you can use SSVEP to measure contrast responses, you can also use it to measure things that modulate contrast responses. These include adaptation, masking, suppression, attention (feature and space), clinical things.</p>
<p><span id="anchor-7"></span>Adaptation:</p>
<p>Continuous exposure to high-contrast patterns reduces contrast sensitivity, which can be measured using SSVEP (Ross et al., 1989). Others? Baker recent gain control paper is perhaps worth mentioning here as a ‘confound’ of sorts. Engel 2018 <a href="https://www.zotero.org/google-docs/?kdURiS"><em>(Vergeer et al., 2018)</em></a>. This paper is interesting <a href="https://www.zotero.org/google-docs/?J2EO3d"><em>(Rideaux et al., 2023)</em></a> and &gt;sort&lt; of SSVEP.</p>
<p><span id="anchor-8"></span>Masking:</p>
<p>High contrast masks can suppress the visibility of low contrast patterns, which has implications in SSVEP amplitude (Haynes et al., 2003).</p>
<p>Attention: Directing attention can enhance contrast sensitivity, as shown in studies using SSVEP (Müller et al., 2006). Also Tsai (dynamics), Baker / Wade (several), Winawer? I think JW has a nice dynamic model of normalization with some MEG data. Busse et al cat/human comparison. Candy and Norcia 2001 JNS <a href="https://www.zotero.org/google-docs/?7hhs5Z">(Candy et al., 2001)</a></p>
<p>Ross, J., Speed, H. D., &amp; Morgan, M. J. (1989). The effects of adaptation and masking on incremental thresholds for contrast. Vision research, 29(2), 205-215.</p>
<p>Haynes, J. D., Roth, G., Stadler, M., &amp; Heinze, H. J. (2003). Neuromagnetic correlates of perceived contrast in primary visual cortex. Journal of Neurophysiology, 89(6), 2655-2666.</p>
<p>Müller, M. M., Picton, T. W., Valdes-Sosa, P., Riera, J., Teder-Sälejärvi, W. A., &amp; Hillyard, S. A. (2006). Effects of spatial selective attention on the steady-state visual evoked potential in the 20–28 Hz range. Cognitive Brain Research, 24(1), 1-13.</p>
<p>5. Clinical implications</p>
<p><span id="anchor-9"></span>Clinical applications (this is a whole section)</p>
<p>Not sure exactly how SSVEP used in clinic. mfVEP?</p>
<p>, e.g., in monitoring visual impairments, tracking neuronal diseases, or neurofeedback (Norcia et al., 2015).</p>
<p>Tsai epilepsy <a href="https://www.zotero.org/google-docs/?AdhH3f">(Tsai et al., 2011)</a>. Other photosensitive epilepsy: Porciatti <a href="https://www.zotero.org/google-docs/?UTBQbV">(Porciatti et al., 2000)</a></p>
<p>Citation:</p>
<p>Migraine (Regan et al). Autism?</p>
<p>Norcia, A. M., Appelbaum, L. G., Ales, J. M., Cottereau, B. R., &amp; Rossion, B. (2015). The steady-state visual evoked potential in vision research: A review. Journal of vision, 15(6), 4-4.</p>
<p>Animal work: Flies (Eliott, West, Himmelberg, Ales, Norcia): Mice/rats (probably many - can’t think off the top of my head - we were working with a mouse EEG person at UCSF about 12 years ago...), Monkeys (Kiorpes?),</p>
<p><span id="anchor-10"></span>6. Future directions</p>
<p>Use as a readout of modulations. TMS? FUS? Marmite B12 / Fluoxetine / amblyopia in Rats,</p>
<p>GABA Huang</p>
<p>There is a lot of SSVEP interest these days because of BCIs. I think it’s pretty weak but there is &gt;so much&lt; of it that it might be worth mentioning...</p>
<p>Advanced signal processing techniques and machine learning can be integrated to improve SSVEP-based systems (Zhu et al., 2010).</p>
<p>Exploring new clinical and diagnostic applications, understanding neurological diseases, and developing novel therapeutic interventions.</p>
<p>Citation:</p>
<p>Zhu, D., Bieger, J., Molina, G. G., &amp; Aarts, R. M. (2010). A survey of stimulation methods used in SSVEP-based BCIs. Computational intelligence and neuroscience, 2010.</p>

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-dawson_summation_1954" class="csl-entry" role="listitem">
Dawson, G. D. 1954. <span>“A Summation Technique for the Detection of Small Evoked Potentials.”</span> <em>Electroencephalography and Clinical Neurophysiology</em> 6 (January): 65–84. <a href="https://doi.org/10.1016/0013-4694(54)90007-3">https://doi.org/10.1016/0013-4694(54)90007-3</a>.
</div>
<div id="ref-porciatti_lack_2000" class="csl-entry" role="listitem">
Porciatti, V., P. Bonanni, A. Fiorentini, and R. Guerrini. 2000. <span>“Lack of Cortical Contrast Gain Control in Human Photosensitive Epilepsy.”</span> <em>Nature Neuroscience</em> 3 (3): 259–63. <a href="https://doi.org/10.1038/72972">https://doi.org/10.1038/72972</a>.
</div>
<div id="ref-tsai_contrast_2011" class="csl-entry" role="listitem">
Tsai, Jeffrey J., Anthony M. Norcia, Justin M. Ales, and Alex R. Wade. 2011. <span>“Contrast Gain Control Abnormalities in Idiopathic Generalized Epilepsy.”</span> <em>Annals of Neurology</em> 70 (4): 574–82. <a href="https://doi.org/10.1002/ana.22462">https://doi.org/10.1002/ana.22462</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>